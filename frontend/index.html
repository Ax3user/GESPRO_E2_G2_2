<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Gestor de tareas</title>
  <style>
    body { font-family: Arial, sans-serif; background: #f4f4f4; margin: 30px; }
    h1 { margin-bottom: 10px; }

    .form { background: white; padding: 15px; border-radius: 6px; margin-bottom: 12px; display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    input, select, button { padding: 6px; }
    button { cursor: pointer; }
    #msg { font-weight: bold; margin-left: 6px; }

    #healthStatus { margin: 0 0 10px 0; font-weight: bold; }

    .board { display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; }
    .col { background: white; padding: 10px; border-radius: 6px; min-height: 340px; }
    .col h3 { text-align: center; margin: 6px 0 10px; }

    .lane { padding: 8px; border-radius: 6px; min-height: 240px; }

    .task {
      background: #eee;
      padding: 10px;
      border-radius: 6px;
      margin-bottom: 8px;
      cursor: grab;
      user-select: none;
      border: 1px solid rgba(0,0,0,0.08);
    }
    .task:active { cursor: grabbing; }

    .todo { background: #e0e7ff; }
    .progress { background: #fff4cc; }
    .done { background: #d1fadf; }

    .drop-hover { outline: 2px dashed #333; outline-offset: 4px; }

    .meta { font-size: 12px; color:#333; margin-top:6px; display:flex; gap:10px; flex-wrap:wrap; }
    .pill { background: rgba(255,255,255,0.65); border:1px solid rgba(0,0,0,0.08); padding:2px 8px; border-radius:999px; font-weight:bold; }
    .warn { color: #b42318; }
    .ok { color: #067647; }

    .wipbar{
      background: white;
      padding: 10px 15px;
      border-radius: 6px;
      margin: 0 0 18px 0;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
      border: 1px solid rgba(0,0,0,0.06);
    }
    .wip-left{display:flex; align-items:center; gap:10px; flex-wrap:wrap;}
    .wip-right{display:flex; align-items:center; gap:8px; flex-wrap:wrap;}
    .wip-count{font-weight:bold;}
    .small{font-size:12px; color:#555;}
  </style>
</head>
<body>

<h1>Gestor de tareas</h1>

<div class="form">
  <input id="title" placeholder="Título de la tarea">
  <select id="status">
    <option value="TODO">TODO</option>
    <option value="IN_PROGRESS">IN_PROGRESS</option>
    <option value="DONE">DONE</option>
  </select>

  <input id="estimate" type="number" min="0" step="1" placeholder="Estimado (min)" style="width:140px;">

  <button onclick="createTask()">Crear</button>
  <button onclick="checkHealth()">Probar /health</button>
  <span id="msg"></span>
</div>

<p id="healthStatus"></p>

<!-- ✅ WIP LIMIT BAR -->
<div class="wipbar">
  <div class="wip-left">
    <span class="wip-count" id="wipCount">IN_PROGRESS: 0/5</span>
    <span class="small">Límite de WIP (tareas en progreso)</span>
  </div>

  <div class="wip-right">
    <label class="small" for="wipLimit">Límite:</label>
    <input id="wipLimit" type="number" min="1" step="1" value="5" style="width:80px;">
    <button onclick="applyWipLimit()">Aplicar</button>
  </div>
</div>

<div class="board">
  <div class="col">
    <h3>TODO</h3>
    <div class="lane" id="todoLane" data-status="TODO"></div>
  </div>

  <div class="col">
    <h3>IN_PROGRESS</h3>
    <div class="lane" id="progressLane" data-status="IN_PROGRESS"></div>
  </div>

  <div class="col">
    <h3>DONE</h3>
    <div class="lane" id="doneLane" data-status="DONE"></div>
  </div>
</div>

<script>
const API = "http://127.0.0.1:5000";

const msg = document.getElementById("msg");
const healthEl = document.getElementById("healthStatus");

const todoLane = document.getElementById("todoLane");
const progressLane = document.getElementById("progressLane");
const doneLane = document.getElementById("doneLane");

const wipCountEl = document.getElementById("wipCount");
const wipLimitInput = document.getElementById("wipLimit");

let draggedTaskId = null;
let tasksCache = [];
let tickTimer = null;

// WIP limit (editable por usuario)
let wipLimit = 5;

// Guardar / cargar WIP limit (opcional pero útil)
(function initWip(){
  const saved = localStorage.getItem("wipLimit");
  if (saved) {
    const n = parseInt(saved, 10);
    if (!isNaN(n) && n >= 1) wipLimit = n;
  }
  wipLimitInput.value = wipLimit;
})();

function applyWipLimit(){
  const n = parseInt(wipLimitInput.value, 10);
  if (isNaN(n) || n < 1){
    setMsg("El límite debe ser un número >= 1", false);
    wipLimitInput.value = wipLimit;
    return;
  }
  wipLimit = n;
  localStorage.setItem("wipLimit", String(wipLimit));
  setMsg(`Límite IN_PROGRESS actualizado a ${wipLimit}`, true);
  updateWipCounter();
}

function setMsg(text, ok=true){
  msg.textContent = text || "";
  msg.style.color = ok ? "green" : "crimson";
}

function fmtDuration(sec){
  sec = Math.max(0, Math.floor(sec || 0));
  const h = Math.floor(sec / 3600);
  const m = Math.floor((sec % 3600) / 60);
  const s = sec % 60;
  if (h > 0) return `${h}h ${m}m ${s}s`;
  if (m > 0) return `${m}m ${s}s`;
  return `${s}s`;
}

function updateWipCounter(){
  const inprogCount = tasksCache.filter(t => t.status === "IN_PROGRESS").length;
  wipCountEl.textContent = `IN_PROGRESS: ${inprogCount}/${wipLimit}`;
  wipCountEl.style.color = (inprogCount > wipLimit) ? "crimson" : "#111";
  return inprogCount;
}

function makeTaskDiv(t){
  const div = document.createElement("div");
  div.className = "task";
  div.setAttribute("draggable", "true");
  div.dataset.id = t.id;

  const estimateMin = Number(t.estimate_min || 0);
  const estimateSec = estimateMin * 60;

  let liveSec = null;
  if (t.status === "IN_PROGRESS" && t.started_at) {
    liveSec = Math.floor(Date.now()/1000) - Number(t.started_at);
  }

  let compareText = "";
  let compareClass = "ok";
  if (t.status === "DONE" && typeof t.actual_sec === "number") {
    const realSec = Number(t.actual_sec);
    const diff = realSec - estimateSec;
    if (estimateSec === 0) {
      compareText = `Real: ${fmtDuration(realSec)} (sin estimado)`;
      compareClass = "ok";
    } else if (diff <= 0) {
      compareText = `Estimado: ${fmtDuration(estimateSec)} • Real: ${fmtDuration(realSec)} • ✅ ${fmtDuration(Math.abs(diff))} antes`;
      compareClass = "ok";
    } else {
      compareText = `Estimado: ${fmtDuration(estimateSec)} • Real: ${fmtDuration(realSec)} • ⚠️ ${fmtDuration(diff)} tarde`;
      compareClass = "warn";
    }
  }

  const title = document.createElement("div");
  title.style.fontWeight = "bold";
  title.textContent = `#${t.id} ${t.title}`;
  div.appendChild(title);

  const meta = document.createElement("div");
  meta.className = "meta";

  const pillEst = document.createElement("span");
  pillEst.className = "pill";
  pillEst.textContent = `Estimado: ${estimateMin} min`;
  meta.appendChild(pillEst);

  if (t.status === "IN_PROGRESS") {
    const pillLive = document.createElement("span");
    pillLive.className = "pill";
    pillLive.id = `timer-${t.id}`;
    pillLive.textContent = `Tiempo real: ${fmtDuration(liveSec || 0)}`;
    meta.appendChild(pillLive);
  }

  if (t.status === "DONE") {
    const pillCmp = document.createElement("span");
    pillCmp.className = `pill ${compareClass}`;
    pillCmp.textContent = compareText || "Completada";
    meta.appendChild(pillCmp);
  }

  div.appendChild(meta);

  div.addEventListener("dragstart", (e) => {
    draggedTaskId = Number(div.dataset.id);
    e.dataTransfer.effectAllowed = "move";
    e.dataTransfer.setData("text/plain", String(draggedTaskId));
  });
  div.addEventListener("dragend", () => { draggedTaskId = null; });

  return div;
}

async function loadTasks() {
  const res = await fetch(API + "/tasks");
  const tasks = await res.json();
  tasksCache = Array.isArray(tasks) ? tasks : [];

  todoLane.innerHTML = "";
  progressLane.innerHTML = "";
  doneLane.innerHTML = "";

  tasksCache.forEach(t => {
    const div = makeTaskDiv(t);

    if (t.status === "TODO") { div.classList.add("todo"); todoLane.appendChild(div); }
    else if (t.status === "IN_PROGRESS") { div.classList.add("progress"); progressLane.appendChild(div); }
    else if (t.status === "DONE") { div.classList.add("done"); doneLane.appendChild(div); }
  });

  updateWipCounter();
  startTicker();
}

function startTicker(){
  if (tickTimer) clearInterval(tickTimer);

  const hasInProgress = tasksCache.some(t => t.status === "IN_PROGRESS" && t.started_at);
  if (!hasInProgress) return;

  tickTimer = setInterval(() => {
    const now = Math.floor(Date.now()/1000);
    tasksCache.forEach(t => {
      if (t.status === "IN_PROGRESS" && t.started_at) {
        const el = document.getElementById(`timer-${t.id}`);
        if (el) el.textContent = `Tiempo real: ${fmtDuration(now - Number(t.started_at))}`;
      }
    });
  }, 1000);
}

async function createTask() {
  setMsg("");

  const title = document.getElementById("title").value.trim();
  const status = document.getElementById("status").value;
  const estimateMin = document.getElementById("estimate").value;

  const res = await fetch(API + "/tasks", {
    method: "POST",
    headers: {"Content-Type": "application/json"},
    body: JSON.stringify({ title, status, estimate_min: estimateMin })
  });

  const data = await res.json();
  if (!res.ok) { setMsg(data.error || "Error", false); return; }

  document.getElementById("title").value = "";
  document.getElementById("estimate").value = "";
  setMsg(`Creada: #${data.id}`, true);
  loadTasks();
}

async function checkHealth() {
  healthEl.textContent = "Consultando /health...";
  try {
    const res = await fetch(API + "/health");
    const data = await res.json();
    healthEl.textContent = `Backend: ${data.status} – ${data.message} (tareas: ${data.tasks_count})`;
    healthEl.style.color = "green";
  } catch (e) {
    healthEl.textContent = "No se pudo conectar con el backend";
    healthEl.style.color = "crimson";
  }
}

async function moveTask(taskId, newStatus){
  const res = await fetch(`${API}/tasks/${taskId}`, {
    method: "PATCH",
    headers: {"Content-Type":"application/json"},
    body: JSON.stringify({ status: newStatus })
  });
  const data = await res.json();
  if (!res.ok){ setMsg(data.error || "No se pudo mover la tarea", false); return; }

  setMsg(`Movida: #${data.id} → ${data.status}`, true);
  loadTasks();
}

function enableDrop(lane){
  lane.addEventListener("dragover", (e) => {
    // Si es IN_PROGRESS, aplicamos WIP limit
    const targetStatus = lane.dataset.status;
    if (targetStatus === "IN_PROGRESS") {
      const inprogCount = tasksCache.filter(t => t.status === "IN_PROGRESS").length;

      // Si ya está al límite, no permitimos drop (salvo si la que arrastras ya estaba IN_PROGRESS)
      const dragged = tasksCache.find(t => t.id === draggedTaskId);
      const draggedWasInProg = dragged && dragged.status === "IN_PROGRESS";

      if (inprogCount >= wipLimit && !draggedWasInProg) {
        // No prevenimos default -> no se podrá soltar
        lane.classList.remove("drop-hover");
        return;
      }
    }

    e.preventDefault();
    lane.classList.add("drop-hover");
    e.dataTransfer.dropEffect = "move";
  });

  lane.addEventListener("dragleave", () => lane.classList.remove("drop-hover"));

  lane.addEventListener("drop", (e) => {
    const targetStatus = lane.dataset.status;

    // WIP check final
    if (targetStatus === "IN_PROGRESS") {
      const inprogCount = tasksCache.filter(t => t.status === "IN_PROGRESS").length;
      const dragged = tasksCache.find(t => t.id === draggedTaskId);
      const draggedWasInProg = dragged && dragged.status === "IN_PROGRESS";

      if (inprogCount >= wipLimit && !draggedWasInProg) {
        setMsg(`Límite alcanzado: IN_PROGRESS ${inprogCount}/${wipLimit}`, false);
        lane.classList.remove("drop-hover");
        return;
      }
    }

    e.preventDefault();
    lane.classList.remove("drop-hover");

    const idFromTransfer = Number(e.dataTransfer.getData("text/plain"));
    const taskId = draggedTaskId ?? idFromTransfer;
    const newStatus = lane.dataset.status;

    if (!taskId || !newStatus) return;
    moveTask(taskId, newStatus);
  });
}

enableDrop(todoLane);
enableDrop(progressLane);
enableDrop(doneLane);

loadTasks();
</script>

</body>
</html>
