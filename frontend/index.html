<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Gestor de tareas</title>
  <style>
    body { font-family: Arial, sans-serif; background: #f4f4f4; margin: 30px; }
    h1 { margin-bottom: 10px; }

    .form { background: white; padding: 15px; border-radius: 6px; margin-bottom: 12px; display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    input, select, button { padding: 6px; }
    button { cursor: pointer; }
    #msg { font-weight: bold; margin-left: 6px; }
    #healthStatus { margin: 0 0 10px 0; font-weight: bold; }

    .wipbar{
      background: white; padding: 10px 15px; border-radius: 6px; margin: 0 0 18px 0;
      display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap;
      border: 1px solid rgba(0,0,0,0.06);
    }
    .wip-left{display:flex; align-items:center; gap:10px; flex-wrap:wrap;}
    .wip-right{display:flex; align-items:center; gap:8px; flex-wrap:wrap;}
    .wip-count{font-weight:bold;}
    .small{font-size:12px; color:#555;}

    .grid2 { display:grid; grid-template-columns: 1fr 2fr; gap: 15px; margin-bottom: 15px; }
    .card { background:white; border-radius:6px; padding:12px; border:1px solid rgba(0,0,0,0.06); }

    table { width:100%; border-collapse: collapse; }
    th, td { border-bottom: 1px solid rgba(0,0,0,0.08); padding: 8px; text-align:left; font-size: 14px; }
    th { font-size: 12px; text-transform: uppercase; color:#444; }
    .p-row { cursor: grab; user-select:none; }
    .p-row:active { cursor: grabbing; }
    .pill { background: rgba(0,0,0,0.06); padding:2px 8px; border-radius:999px; font-weight:bold; font-size:12px; display:inline-block; }
    .role-po { background: rgba(255, 200, 0, 0.25); }
    .role-m { background: rgba(0, 120, 255, 0.15); }
    .role-v { background: rgba(0, 200, 120, 0.18); }

    .board { display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; }
    .col { background: white; padding: 10px; border-radius: 6px; min-height: 340px; }
    .col h3 { text-align: center; margin: 6px 0 10px; }
    .lane { padding: 8px; border-radius: 6px; min-height: 240px; }

    .task {
      background: #eee; padding: 10px; border-radius: 6px; margin-bottom: 8px;
      cursor: grab; user-select: none; border: 1px solid rgba(0,0,0,0.08);
    }
    .task:active { cursor: grabbing; }

    .todo { background: #e0e7ff; }
    .progress { background: #fff4cc; }
    .done { background: #d1fadf; }

    .drop-hover { outline: 2px dashed #333; outline-offset: 4px; }
    .drop-task-hover { outline: 2px dashed #111; outline-offset: 6px; }

    .meta { font-size: 12px; color:#333; margin-top:6px; display:flex; gap:10px; flex-wrap:wrap; }
    .warn { color: #b42318; }
    .ok { color: #067647; }

    .assignees { margin-top:8px; display:flex; gap:6px; flex-wrap:wrap; }
    .assignee {
      background: rgba(255,255,255,0.6);
      border: 1px solid rgba(0,0,0,0.08);
      padding: 2px 8px;
      border-radius: 999px;
      font-size: 12px;
      font-weight: bold;
      cursor: pointer;
    }
    .assignee:hover { opacity: 0.85; }

    .hint { font-size: 12px; color:#666; margin-top: 6px; }
  </style>
</head>
<body>

<!-- ================= LOGIN ================= -->
<div id="loginBox" style="background:white;padding:20px;border-radius:6px;width:300px;margin-bottom:20px;">
  <h3>Iniciar sesión</h3>

  <select id="loginUser" style="width:100%; margin-bottom:10px;"></select>

  <button onclick="login()">Entrar</button>
</div>

<div id="appContent" style="display:none;">
<!-- TODO TU HTML EXISTENTE VA AQUÍ ABAJO -->


<h1>Gestor de tareas</h1>

<div class="form">
  <input id="title" placeholder="Título de la tarea">
  <select id="status">
    <option value="TODO">TODO</option>
    <option value="IN_PROGRESS">IN_PROGRESS</option>
    <option value="DONE">DONE</option>
  </select>
  <input id="estimate" type="number" min="0" step="1" placeholder="Estimado (min)" style="width:140px;">
  <select id="assignOne" style="min-width:180px;">
    <option value="">Asignar a (opcional)</option>
  </select>
  <button onclick="createTask()">Crear</button>
  <button onclick="checkHealth()">Probar /health</button>
  <span id="msg"></span>
</div>

<p id="healthStatus"></p>

<div class="wipbar">
  <div class="wip-left">
    <span class="wip-count" id="wipCount">IN_PROGRESS: 0/5</span>
    <span class="small">Límite de WIP (tareas en progreso)</span>
  </div>
  <div class="wip-right">
    <label class="small" for="wipLimit">Límite:</label>
    <input id="wipLimit" type="number" min="1" step="1" value="5" style="width:80px;">
    <button onclick="applyWipLimit()">Aplicar</button>
  </div>
</div>

<!-- ✅ Participantes + Tablero -->
<div class="grid2">
  <div class="card">
    <h3 style="margin: 0 0 10px;">Participantes</h3>

    <div style="display:flex; gap:8px; flex-wrap:wrap; margin-bottom:10px;">
      <input id="pName" placeholder="Nombre" style="flex:1; min-width:140px;">
      <select id="pRole" style="min-width:160px;">
        <option value="member" selected>member</option>
        <option value="visualizer">visualizer</option>
      </select>
      <button onclick="addParticipant()">Agregar</button>
    </div>

    <div class="hint">Arrastra un participante a una tarea para asignarlo.</div>

    <table>
      <thead>
        <tr>
          <th>Nombre</th>
          <th>Rol</th>
          <th></th>
        </tr>
      </thead>
      <tbody id="participantsBody"></tbody>
    </table>
  </div>

  <div class="card">
    <h3 style="margin: 0 0 10px;">Tablero</h3>
    <div class="board">
      <div class="col">
        <h3>TODO</h3>
        <div class="lane" id="todoLane" data-status="TODO"></div>
      </div>

      <div class="col">
        <h3>IN_PROGRESS</h3>
        <div class="lane" id="progressLane" data-status="IN_PROGRESS"></div>
      </div>

      <div class="col">
        <h3>DONE</h3>
        <div class="lane" id="doneLane" data-status="DONE"></div>
      </div>
    </div>
  </div>
</div>

<script>

async function loadUsersForLogin(){
  const res = await fetch(API + "/participants");
  const users = await res.json();

  const sel = document.getElementById("loginUser");
  sel.innerHTML = "";

  users.forEach(u=>{
    const opt = document.createElement("option");
    opt.value = u.name;
    opt.textContent = `${u.name} (${u.role})`;
    sel.appendChild(opt);
  });
}

function login(){
  const sel = document.getElementById("loginUser");
  currentUser = sel.value;

  fetch(API + "/participants")
    .then(r=>r.json())
    .then(data=>{
      const u = data.find(x=>x.name===currentUser);
      if(!u){
        alert("Usuario inválido");
        return;
      }
      currentRole = u.role;

      document.getElementById("loginBox").style.display="none";
      document.getElementById("appContent").style.display="block";

      applyPermissions();
    });
}

function applyPermissions(){

  // Visualizer → solo ver
  if(currentRole==="visualizer"){
    document.querySelectorAll("input, select, button").forEach(el=>{
      el.disabled = true;
    });
  }

  // Member → no crear tareas
  if(currentRole==="member"){
    document.querySelector("button[onclick='createTask()']").disabled=true;
  }

  // Product Owner → todo habilitado
}

const API = "http://127.0.0.1:5000";

const msg = document.getElementById("msg");
const healthEl = document.getElementById("healthStatus");

const todoLane = document.getElementById("todoLane");
const progressLane = document.getElementById("progressLane");
const doneLane = document.getElementById("doneLane");

const participantsBody = document.getElementById("participantsBody");

const wipCountEl = document.getElementById("wipCount");
const wipLimitInput = document.getElementById("wipLimit");

let draggedTaskId = null;
let draggedParticipant = null; // {id, name}
let tasksCache = [];
let participantsCache = [];
let tickTimer = null;

let wipLimit = 5;

let currentUser = null;
let currentRole = null;


// -------- WIP init --------
(function initWip(){
  const saved = localStorage.getItem("wipLimit");
  if (saved) {
    const n = parseInt(saved, 10);
    if (!isNaN(n) && n >= 1) wipLimit = n;
  }
  wipLimitInput.value = wipLimit;
})();

function applyWipLimit(){
  const n = parseInt(wipLimitInput.value, 10);
  if (isNaN(n) || n < 1){
    setMsg("El límite debe ser un número >= 1", false);
    wipLimitInput.value = wipLimit;
    return;
  }
  wipLimit = n;
  localStorage.setItem("wipLimit", String(wipLimit));
  setMsg(`Límite IN_PROGRESS actualizado a ${wipLimit}`, true);
  updateWipCounter();
}

function setMsg(text, ok=true){
  msg.textContent = text || "";
  msg.style.color = ok ? "green" : "crimson";
}

function fmtDuration(sec){
  sec = Math.max(0, Math.floor(sec || 0));
  const h = Math.floor(sec / 3600);
  const m = Math.floor((sec % 3600) / 60);
  const s = sec % 60;
  if (h > 0) return `${h}h ${m}m ${s}s`;
  if (m > 0) return `${m}m ${s}s`;
  return `${s}s`;
}

function updateWipCounter(){
  const inprogCount = tasksCache.filter(t => t.status === "IN_PROGRESS").length;
  wipCountEl.textContent = `IN_PROGRESS: ${inprogCount}/${wipLimit}`;
  wipCountEl.style.color = (inprogCount > wipLimit) ? "crimson" : "#111";
  return inprogCount;
}

// ---------------------- Backend calls: participants ----------------------
async function fetchParticipants(){
  const res = await fetch(API + "/participants");
  participantsCache = await res.json();
}

async function addParticipant(){
  const name = document.getElementById("pName").value.trim();
  const role = document.getElementById("pRole").value;

  if (!name) { setMsg("Nombre vacío", false); return; }

  const res = await fetch(API + "/participants", {
    method: "POST",
    headers: {"Content-Type":"application/json"},
    body: JSON.stringify({ name, role })
  });
  const data = await res.json();
  if (!res.ok) { setMsg(data.error || "Error al agregar participante", false); return; }

  document.getElementById("pName").value = "";
  setMsg(`Participante agregado: ${data.name}`, true);
  await loadAll();
  loadUsersForLogin();

}

async function patchParticipant(pid, payload){
  const res = await fetch(`${API}/participants/${pid}`, {
    method: "PATCH",
    headers: {"Content-Type":"application/json"},
    body: JSON.stringify(payload)
  });
  const data = await res.json();
  if (!res.ok) { setMsg(data.error || "Error al actualizar participante", false); return null; }
  return data;
}

async function deleteParticipant(pid){
  const res = await fetch(`${API}/participants/${pid}`, { method:"DELETE" });
  const data = await res.json();
  if (!res.ok) { setMsg(data.error || "Error al borrar participante", false); return; }
  setMsg("Participante eliminado", true);
  await loadAll();
}

function rolePillClass(role){
  if (role === "product_owner") return "role-po";
  if (role === "visualizer") return "role-v";
  return "role-m";
}

function renderParticipants(){
  participantsBody.innerHTML = "";

  participantsCache.forEach(p => {
    const tr = document.createElement("tr");
    tr.className = "p-row";
    tr.setAttribute("draggable", "true");
    tr.dataset.pid = p.id;

    // drag participant
    tr.addEventListener("dragstart", (e) => {
      draggedParticipant = { id: p.id, name: p.name };
      e.dataTransfer.effectAllowed = "copy";
      e.dataTransfer.setData("application/x-participant", JSON.stringify(draggedParticipant));
    });
    tr.addEventListener("dragend", () => { draggedParticipant = null; });

    const tdName = document.createElement("td");
    const nameInput = document.createElement("input");
    nameInput.value = p.name;
    nameInput.style.width = "95%";
    nameInput.addEventListener("blur", async () => {
      const newName = nameInput.value.trim();
      if (!newName) { setMsg("Nombre vacío", false); nameInput.value = p.name; return; }
      if (newName !== p.name) {
        await patchParticipant(p.id, { name: newName });
        await loadAll(); // actualiza y evita inconsistencias
      }
    });
    tdName.appendChild(nameInput);

    const tdRole = document.createElement("td");
    const roleSelect = document.createElement("select");
    roleSelect.innerHTML = `
      <option value="product_owner">product owner</option>
      <option value="member">member</option>
      <option value="visualizer">visualizer</option>
    `;
    roleSelect.value = p.role;

    // Si es PO, bloqueamos edición del rol
    if (p.role === "product_owner") {
      roleSelect.disabled = true;
    }

    roleSelect.addEventListener("change", async () => {
      await patchParticipant(p.id, { role: roleSelect.value });
      await loadAll();
    });
    tdRole.appendChild(roleSelect);

    const tdDel = document.createElement("td");
    const delBtn = document.createElement("button");
    delBtn.textContent = "X";
    delBtn.title = "Eliminar";
    delBtn.addEventListener("click", () => deleteParticipant(p.id));
    tdDel.appendChild(delBtn);

    tr.appendChild(tdName);
    tr.appendChild(tdRole);
    tr.appendChild(tdDel);

    participantsBody.appendChild(tr);
  });
}

function renderAssigneeDropdown(){
  const sel = document.getElementById("assignOne");
  if (!sel) return;

  sel.innerHTML = `<option value="">Asignar a (opcional)</option>`;
  participantsCache.forEach(p => {
    const opt = document.createElement("option");
    opt.value = p.name; // guardamos el nombre
    opt.textContent = `${p.name} (${p.role})`;
    sel.appendChild(opt);
  });
}


// ---------------------- Backend calls: tasks ----------------------
async function patchTask(taskId, payload){
  const res = await fetch(`${API}/tasks/${taskId}`, {
    method: "PATCH",
    headers: {"Content-Type":"application/json"},
    body: JSON.stringify(payload)
  });
  const data = await res.json();
  if (!res.ok) { setMsg(data.error || "Error al actualizar tarea", false); return null; }
  return data;
}

async function moveTask(taskId, newStatus){
  const updated = await patchTask(taskId, { status: newStatus });
  if (updated) {
    setMsg(`Movida: #${updated.id} → ${updated.status}`, true);
    await loadTasks();
  }
}

async function assignParticipantToTask(taskId, name){
  const updated = await patchTask(taskId, { add_assignee: name });
  if (updated) {
    setMsg(`Asignado: ${name} → #${taskId}`, true);
    await loadTasks();
  }
}

async function removeAssigneeFromTask(taskId, name){
  const updated = await patchTask(taskId, { remove_assignee: name });
  if (updated) {
    setMsg(`Quitado: ${name} de #${taskId}`, true);
    await loadTasks();
  }
}

// ---------------------- UI: tasks render ----------------------
function makeTaskDiv(t){
  const div = document.createElement("div");
  div.className = "task";
  div.setAttribute("draggable", "true");
  div.dataset.id = t.id;

  // ✅ Drop target for participant assignment
  div.addEventListener("dragover", (e) => {
    // Permitir drop si viene un participante
    const types = Array.from(e.dataTransfer.types || []);
    if (types.includes("application/x-participant") || draggedParticipant) {
      e.preventDefault();
      div.classList.add("drop-task-hover");
      e.dataTransfer.dropEffect = "copy";
    }
  });
  div.addEventListener("dragleave", () => div.classList.remove("drop-task-hover"));
  div.addEventListener("drop", async (e) => {
    const types = Array.from(e.dataTransfer.types || []);
    if (types.includes("application/x-participant") || draggedParticipant) {
      e.preventDefault();
      div.classList.remove("drop-task-hover");

      let payload = draggedParticipant;
      if (!payload) {
        try {
          payload = JSON.parse(e.dataTransfer.getData("application/x-participant"));
        } catch {}
      }
      if (payload && payload.name) {
        await assignParticipantToTask(t.id, payload.name);
      }
    }
  });

  // Drag task (para mover entre columnas)
  div.addEventListener("dragstart", (e) => {
    draggedTaskId = Number(div.dataset.id);
    e.dataTransfer.effectAllowed = "move";
    e.dataTransfer.setData("text/plain", String(draggedTaskId));
  });
  div.addEventListener("dragend", () => { draggedTaskId = null; });

  // Título (doble click para editar)
  const title = document.createElement("div");
  title.style.fontWeight = "bold";
  title.style.cursor = "text";
  title.textContent = `#${t.id} ${t.title}`;
  title.addEventListener("dblclick", () => startEditTitle(t.id, t.title));
  div.appendChild(title);

  // Estimado + tiempos
  const estimateMin = Number(t.estimate_min || 0);
  const estimateSec = estimateMin * 60;

  let liveSec = null;
  if (t.status === "IN_PROGRESS" && t.started_at) {
    liveSec = Math.floor(Date.now()/1000) - Number(t.started_at);
  }

  let compareText = "";
  let compareClass = "ok";
  if (t.status === "DONE" && typeof t.actual_sec === "number") {
    const realSec = Number(t.actual_sec);
    const diff = realSec - estimateSec;
    if (estimateSec === 0) {
      compareText = `Real: ${fmtDuration(realSec)} (sin estimado)`;
      compareClass = "ok";
    } else if (diff <= 0) {
      compareText = `Estimado: ${fmtDuration(estimateSec)} • Real: ${fmtDuration(realSec)} • ✅ ${fmtDuration(Math.abs(diff))} antes`;
      compareClass = "ok";
    } else {
      compareText = `Estimado: ${fmtDuration(estimateSec)} • Real: ${fmtDuration(realSec)} • ⚠️ ${fmtDuration(diff)} tarde`;
      compareClass = "warn";
    }
  }

  const meta = document.createElement("div");
  meta.className = "meta";

  const pillEst = document.createElement("span");
  pillEst.className = "pill";
  pillEst.textContent = `Estimado: ${estimateMin} min`;
  meta.appendChild(pillEst);

  if (t.status === "IN_PROGRESS") {
    const pillLive = document.createElement("span");
    pillLive.className = "pill";
    pillLive.id = `timer-${t.id}`;
    pillLive.textContent = `Tiempo real: ${fmtDuration(liveSec || 0)}`;
    meta.appendChild(pillLive);
  }

  if (t.status === "DONE") {
    const pillCmp = document.createElement("span");
    pillCmp.className = `pill ${compareClass}`;
    pillCmp.textContent = compareText || "Completada";
    meta.appendChild(pillCmp);
  }

  div.appendChild(meta);

  // ✅ Assignees (solo nombres)
  const assignees = Array.isArray(t.assignees) ? t.assignees : [];
  if (assignees.length > 0) {
    const wrap = document.createElement("div");
    wrap.className = "assignees";
    assignees.forEach(name => {
      const chip = document.createElement("span");
      chip.className = "assignee";
      chip.textContent = name;
      chip.title = "Click para quitar (opcional)";
      chip.addEventListener("click", () => removeAssigneeFromTask(t.id, name));
      wrap.appendChild(chip);
    });
    div.appendChild(wrap);
  } else {
    const hint = document.createElement("div");
    hint.className = "hint";
    hint.textContent = "Tip: arrastra un participante aquí para asignarlo.";
    div.appendChild(hint);
  }

  return div;
}

async function loadTasks() {
  const res = await fetch(API + "/tasks");
  tasksCache = await res.json();

  todoLane.innerHTML = "";
  progressLane.innerHTML = "";
  doneLane.innerHTML = "";

  tasksCache.forEach(t => {
    const div = makeTaskDiv(t);

    if (t.status === "TODO") { div.classList.add("todo"); todoLane.appendChild(div); }
    else if (t.status === "IN_PROGRESS") { div.classList.add("progress"); progressLane.appendChild(div); }
    else if (t.status === "DONE") { div.classList.add("done"); doneLane.appendChild(div); }
  });

  updateWipCounter();
  startTicker();
}

function startTicker(){
  if (tickTimer) clearInterval(tickTimer);
  const hasInProgress = tasksCache.some(t => t.status === "IN_PROGRESS" && t.started_at);
  if (!hasInProgress) return;

  tickTimer = setInterval(() => {
    const now = Math.floor(Date.now()/1000);
    tasksCache.forEach(t => {
      if (t.status === "IN_PROGRESS" && t.started_at) {
        const el = document.getElementById(`timer-${t.id}`);
        if (el) el.textContent = `Tiempo real: ${fmtDuration(now - Number(t.started_at))}`;
      }
    });
  }, 1000);
}

// Crear tarea
async function createTask() {
  setMsg("");

  const title = document.getElementById("title").value.trim();
  const status = document.getElementById("status").value;
  const estimateMin = document.getElementById("estimate").value;
  const assignName = document.getElementById("assignOne").value;


  const res = await fetch(API + "/tasks", {
    method: "POST",
    headers: {"Content-Type": "application/json"},
    body: JSON.stringify({ title, status, estimate_min: estimateMin })
  });

  const data = await res.json();
  if (!res.ok) { setMsg(data.error || "Error", false); return; }

  document.getElementById("title").value = "";
  document.getElementById("estimate").value = "";
  document.getElementById("assignOne").value = "";

  setMsg(`Creada: #${data.id}`, true);

  // Si seleccionaste a alguien, asignarlo
  if (assignName) {
    await assignParticipantToTask(data.id, assignName);
  } else {
    await loadTasks();
  }
}

// /health
async function checkHealth() {
  healthEl.textContent = "Consultando /health...";
  try {
    const res = await fetch(API + "/health");
    const data = await res.json();
    healthEl.textContent = `Backend: ${data.status} – ${data.message} (tareas: ${data.tasks_count})`;
    healthEl.style.color = "green";
  } catch (e) {
    healthEl.textContent = "No se pudo conectar con el backend";
    healthEl.style.color = "crimson";
  }
}

// Edit title inline (doble click)
async function patchTaskTitle(taskId, newTitle){
  return await patchTask(taskId, { title: newTitle });
}

function startEditTitle(taskId, currentTitle){
  if (document.getElementById("titleEditor")) return;
  const card = document.querySelector(`.task[data-id="${taskId}"]`);
  if (!card) return;

  const titleDiv = card.firstChild;

  const input = document.createElement("input");
  input.id = "titleEditor";
  input.type = "text";
  input.value = currentTitle;
  input.style.width = "100%";
  input.style.padding = "6px";
  input.style.marginTop = "6px";
  input.style.borderRadius = "6px";
  input.style.border = "1px solid rgba(0,0,0,0.2)";

  titleDiv.textContent = `#${taskId} `;
  titleDiv.appendChild(input);
  input.focus();
  input.select();

  const cancel = () => loadTasks();

  const save = async () => {
    const newTitle = input.value.trim();
    if (!newTitle) { setMsg("El título no puede estar vacío", false); cancel(); return; }
    const updated = await patchTaskTitle(taskId, newTitle);
    if (updated) { setMsg(`Título actualizado: #${taskId}`, true); await loadTasks(); }
    else cancel();
  };

  input.addEventListener("keydown", (e) => {
    if (e.key === "Enter") save();
    if (e.key === "Escape") cancel();
  });
  input.addEventListener("blur", save);
}

// Drag & drop lanes (WIP limit)
function enableDrop(lane){
  lane.addEventListener("dragover", (e) => {
    // Solo para mover TAREAS entre columnas:
    if (draggedTaskId == null) return;

    const targetStatus = lane.dataset.status;
    if (targetStatus === "IN_PROGRESS") {
      const inprogCount = tasksCache.filter(t => t.status === "IN_PROGRESS").length;
      const dragged = tasksCache.find(t => t.id === draggedTaskId);
      const draggedWasInProg = dragged && dragged.status === "IN_PROGRESS";
      if (inprogCount >= wipLimit && !draggedWasInProg) return;
    }

    e.preventDefault();
    lane.classList.add("drop-hover");
    e.dataTransfer.dropEffect = "move";
  });

  lane.addEventListener("dragleave", () => lane.classList.remove("drop-hover"));

  lane.addEventListener("drop", (e) => {
    if (draggedTaskId == null) return;

    const targetStatus = lane.dataset.status;
    if (targetStatus === "IN_PROGRESS") {
      const inprogCount = tasksCache.filter(t => t.status === "IN_PROGRESS").length;
      const dragged = tasksCache.find(t => t.id === draggedTaskId);
      const draggedWasInProg = dragged && dragged.status === "IN_PROGRESS";
      if (inprogCount >= wipLimit && !draggedWasInProg) {
        setMsg(`Límite alcanzado: IN_PROGRESS ${inprogCount}/${wipLimit}`, false);
        lane.classList.remove("drop-hover");
        return;
      }
    }

    e.preventDefault();
    lane.classList.remove("drop-hover");
    moveTask(draggedTaskId, targetStatus);
  });
}

enableDrop(todoLane);
enableDrop(progressLane);
enableDrop(doneLane);

// Cargar todo
async function loadAll(){
  await fetchParticipants();
  renderParticipants();
  renderAssigneeDropdown();
  await loadTasks();
}

loadAll();
loadUsersForLogin();

</script>

</div>
</body>
</html>